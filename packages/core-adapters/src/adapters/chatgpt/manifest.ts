import type { AdapterManifest } from "../../manifest/schema";
import type { AdapterHooks } from "../../manifest/hooks";
import type { MessageNode } from "./shared/types";

// --- Declaration layer ---

export const chatgptManifest = {
  id: "chatgpt-ext",
  version: "2.0.0",
  name: "ChatGPT Extension Parser",
  provider: "chatgpt",

  urls: {
    hostPermissions: [
      "https://chatgpt.com/*",
      "https://chat.openai.com/*",
    ],
    hostPatterns: [
      /^https:\/\/chatgpt\.com\//i,
      /^https:\/\/chat\.openai\.com\//i,
    ],
    conversationUrlPatterns: [
      /^https?:\/\/(?:chat\.openai\.com|chatgpt\.com)\/c\/([a-zA-Z0-9-]+)/,
    ],
  },

  auth: {
    method: "bearer-from-api" as const,
    sessionEndpoint: "https://chatgpt.com/api/auth/session",
    tokenPath: "accessToken",
    expiresPath: "expires",
    tokenTtlMs: 600_000,
  },

  endpoint: {
    urlTemplate:
      "https://chatgpt.com/backend-api/conversation/{conversationId}",
    method: "GET" as const,
    credentials: "include" as const,
    cache: "no-store" as const,
  },

  parsing: {
    role: {
      field: "message.author.role",
      mapping: {
        user: "user" as const,
        assistant: "assistant" as const,
        tool: "assistant" as const,
        system: "skip" as const,
      },
    },
    content: {
      messagesPath: "_linearMessages", // Generated by transformResponse hook
      textPath: "_extractedText", // Processed by extractMessageText hook
      titlePath: "title",
      sortField: "message.create_time",
      sortOrder: "asc" as const,
    },
  },

  injection: {
    copyButton: {
      selectors: [
        "main .sticky .flex.items-center.gap-2",
        'main header [class*="flex"][class*="items-center"]',
        'div[data-testid="conversation-header"] .flex.items-center',
      ],
      position: "prepend" as const,
    },
    listItem: {
      linkSelector: 'nav a[href^="/c/"], nav a[href^="/g/"]',
      idPattern: /\/(?:c|g)\/([a-zA-Z0-9-]+)$/,
      containerSelector: "nav",
    },
    mainContentSelector: "main",
    sidebarSelector: "nav",
  },

  theme: {
    light: {
      primary: "#0d0d0d",
      secondary: "#5d5d5d",
      primaryForeground: "#ffffff",
      secondaryForeground: "#ffffff",
    },
    dark: {
      primary: "#0d0d0d",
      secondary: "#5d5d5d",
      primaryForeground: "#ffffff",
      secondaryForeground: "#ffffff",
    },
  },

  filters: {
    skipWhen: [
      { field: "message.content.content_type", equals: "thoughts" },
      { field: "message.content.content_type", equals: "code" },
      {
        field: "message.metadata.is_visually_hidden_from_conversation",
        equals: true,
      },
      { field: "message.metadata.is_redacted", equals: true },
      { field: "message.metadata.is_user_system_message", equals: true },
      // reasoning_status uses matchesPattern to match non-empty strings (truthy semantics)
      { field: "message.metadata.reasoning_status", matchesPattern: ".+" },
    ],
  },

  conversationUrlTemplate: "https://chatgpt.com/c/{conversationId}",

  meta: {
    reliability: "high" as const,
    coverage: "All ChatGPT conversation types (including GPT-4, o1, Canvas, etc.)",
    lastVerified: "2026-02-07",
    knownLimitations: [
      "Requires waiting when ChatGPT API is rate-limited",
      "DALL-E images only retain alt text descriptions",
    ],
  },
} satisfies AdapterManifest;

// --- Hooks layer ---

/**
 * Why ChatGPT needs hooks:
 * 1. The API response is a tree-shaped mapping that must be linearized first
 * 2. Message content is a complex parts array requiring custom extraction
 */
export const chatgptHooks: AdapterHooks = {
  /**
   * ChatGPT's API returns a tree-shaped mapping that needs to be linearized into a message array.
   */
  transformResponse(raw: unknown) {
    const data = raw as {
      title?: string;
      mapping?: Record<string, MessageNode>;
      current_node?: string;
    };

    const mapping = data.mapping ?? {};
    const linear = buildLinearConversation(mapping, data.current_node);
    const linearMessages = linear
      .map((id) => mapping[id])
      .filter(Boolean);

    return {
      data: { ...data, _linearMessages: linearMessages },
      title: data.title,
    };
  },

  /**
   * ChatGPT message content has a complex structure (parts array with text, images, code, etc.)
   * and requires a dedicated content flattener.
   */
  async extractMessageText(rawMessage: unknown) {
    const node = rawMessage as MessageNode;
    if (!node.message?.content) return "";

    // Reuse existing flattenMessageContent (dynamic import enables tree-shaking)
    const { flattenMessageContent } = await import(
      "./shared/content-flatteners"
    );
    const { stripCitationTokens } = await import("./shared/text-processor");

    let text = await flattenMessageContent(node.message.content, {});
    text = stripCitationTokens(text);
    return text;
  },
};

// --- Helper functions (migrated directly from the original adapter) ---

function buildLinearConversation(
  mapping: Record<string, MessageNode>,
  currentNodeId?: string,
): string[] {
  if (currentNodeId && mapping[currentNodeId]) {
    const ids: string[] = [];
    let nodeId: string | undefined = currentNodeId;
    const visited = new Set<string>();

    while (nodeId && !visited.has(nodeId)) {
      visited.add(nodeId);
      ids.push(nodeId);
      nodeId = mapping[nodeId]?.parent;
    }

    return ids.reverse();
  }

  const nodes = Object.values(mapping)
    .filter(
      (node): node is MessageNode & { id: string } => Boolean(node?.id),
    )
    .sort(
      (a, b) =>
        (a.message?.create_time ?? 0) - (b.message?.create_time ?? 0),
    );

  return nodes.map((node) => node.id);
}
